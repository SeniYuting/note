# 垃圾回收算法
## 标记清除算法
分为“标记 ”和“清除 ”两个阶段，首先标记出所有需要回收的对象，之后统一回收所有被标记的对象。
* 效率低
* 清除后会产生大量的不连续内存碎片，会影响后续的对象分配


## 复制算法（新生代）
内存划分为大小相等的两块，每次只能使用其中一块。当这一块的内存用完了，就将存活的对象复制到另一块上，然后将已经使用过的内存空间一次性清理掉。
* 高效
* 内存缩小为原来的一半

> 商用实现：将内存分为一块大的Eden和两块小的Survivor空间（分别叫from和to），一般比例为8:1，每次将Eden和一个Survivor上存活的对象复制到另一个Survivor空间上，当Survivor空间不足够时，需要依赖其他内存（老年代）进行分配担保。

> JVM区域：总体分两类，heap区和非heap区。heap区又分：Eden Space（伊甸园）、Survivor Space（幸存者区）、Tenured Gen（老年代-养老区）。非heap区又分：Code Cache（代码缓存区）、Perm Gen（永久代）、JVM Stack（java虚拟机栈）、Local Method Stack（本地方法栈）。

## 标记-整理算法（老年代）
分为“标记”和“整理”，标记出所有存活的对象，然后让所有存活的对象移动至内存一端，然后清空端边界以外的内存。

## 分代收集算法
将内存分为新生代与老年代，然后使用复制算法和标记-整理算法结合

[返回目录](../CONTENTS.md)