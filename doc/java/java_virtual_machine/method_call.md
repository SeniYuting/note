# 方法调用
方法调用并不等同于方法执行，方法调用的唯一目的就是确定被调用方法的版本（即调用哪个方法）

## 解析
* 在Java虚拟机规范第三版中，规定了5条方法调用指令：
    * invokestatic：调用静态（类）方法。
    * invokespecial：调用实例方法，特化于super方法调用（父类方法），private方法及实例构造器方法<init>
    * invokevirtual：调用一般实例方法（包括声明为final,但不为private的实例方法）。
    * invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象重写的具体方法
    * invokedynamic：调用动态方法（Java7中新增）
* 被invokestatic和invokespecial调用的方法都是非虚方法，符合这些条件的有：静态方法，私有方法，实例构造器，父类方法（虽然声明为final的方法是用invokevirtual指令调用的，但是我们知道，final方法不能被重写，无法产生多态行为，final方法的行为是非虚的，因此Java虚拟机规范明确说明了final方法是非虚方法）。这些方法在类加载的时候就会把符号引用解析为该方法的直接引用

## 分派

* 变量被声明时的类型叫做变量的静态类型（static type)，又叫做外观类型(Apparent Type)。
* 变量所引用对象的真实类型叫做变量的实际类型（Actual Type)。
* Object obj = new Random()，obj的静态类型是Object,它的实际类型是Random。一个变量的静态类型是不能改变的，在编译期就完全确定下来，就像变量obj，无论怎样，在同一个作用域内，它只能是Object类型，当然了在使用的时候，还是可以对它进行强制类型转换
* 静态分派
    * 发生在编译期，分派是根据静态类型信息发生
    * 发生在编译阶段，因此静态分派的动作不是由虚拟机来执行的
    * 根据接收者的静态类型和方法参数的静态类型来定位方法执行版本的
    * 典型应用是方法重载
* 动态分派
    * 动态分派选择的依据是被调用方法所在对象的运行时类型，也就是接收者的实际类型
    * 方法参数的类型在动态分派选择时将不再起到作用
    * 动态分派的重要体现是重写
    * 可以重写的方法一定是虚方法，在调用虚方法时使用的指令是invokevirtual，invokevirtual指令的运行时解析过程大致分为以下步骤：
        * 找到操作数栈顶的第一个元素所指向对象的实际类型，记作C。也就是找到接收者的实际类型。
        * 如果在类型C中找到相符的方法，进行校验，返回方法的直接引用，查找结束，校验不通过，抛异常。
        * 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和校验过程。
        * 如果始终没找到，抛异常。
* 单分派和多分派
    * 方法的接收者和方法的参数统称为方法的宗量，根据分派基于多少宗量，又可以分成单分派和多分派
    * 静态分派中，编译器要判断接受者的静态类型，确定是哪个类上的方法，这个时候已经判定了接受者这个宗量了，编译器还需要确定参数的静态类型，已确定重载方法中的版本，这个时候又判定了参数这个宗量。所以静态分派是多分派
    * 到了运行期，虚拟机首先就是判断接收者的实际类型，去其上搜索匹配的方法，只判定了接收者的实际类型，方法参数的类型已经不重要了。所以动态分派是单分派

## 动态类型语言支持
* 在java7 JVM中增加了一个新的指令invokedynamic，用于支持动态语言，即允许方法调用可以在运行时指定类和方法，不必在编译的时候确定
* 具体步骤：
    * 根据invokedynamic指令后面的限定符#n，找到调用点限定符在常量池中的位置，调用点限定符的符号引用为CONSTANT_InvokeDynamic_info结构：
    ```
    CONSTANT_InvokeDynamic_info{
        u1 tag;
        u2 bootstrap_method_attr_index;
        u2 name_and_type_index;
    }
    ```
    * 通过CONSTANT_InvokeDynamic_info结构，找到引导方法，引导方法返回值必须是Java.lang.invoke.CallSite类型
    * 调用引导方法。和调用普通方法一样：动态调用点限定符的符号引用解析时出现了异常、或者引导方法执行出现异常、或者引导方法的返回值不匹配、MethodHandle方法描述不一致等都会抛出BootstrapMethodError异常。
    * 执行完引导方法之后，动态调用点会返回一个调用点对象（CallSite）、此对象将会与动态调用点永久绑定，随后调用点对象的MethodHandle将会被调用，即调用invoke、invokeExact等方法。

[返回目录](../CONTENTS.md)