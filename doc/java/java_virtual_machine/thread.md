# 线程
## 线程的实现
实现线程主要有3种方式：
* 使用内核线程实现
    * 内核线程（Kernel-Level Thread）是由操作系统支持的线程，程序一般使用内核线程的一种高级接口——轻量级进程（Light Weight Process）
    * 轻量级进程与内核线程间是一对一的线程模型
* 使用用户线程实现
    * 不是内核线程的线程被称为用户线程
    * 狭义上是完全建立在用户空间的线程库上的，创建、同步、销毁、调度完全在用户态完成
    * 一般是一对多的线程模型
    * 消耗低但是所有操作都需要用户程序自己处理，现在几乎不会使用
* 使用用户线程加轻量级进程混合实现
    * 用户线程还是建立在用户空间中
    * 轻量级进程作为用户线程和内核线程的桥梁
    * 是多对多的模型
> Java线程的实现：在Windows和Linux中，一条Java线程对应一条轻量级进程。在Solaris中，是可以同时支持一对一和多对多的。


## Java线程调度
* 协同式线程调度
    * 线程的执行时间由线程本身控制
    * 实现简单，不存在同步的问题
    * 但是执行时间不可控，如果编写有问题，那么程序将一直阻塞
* 抢占式线程调度（Java采用）
    * 由系统分配执行时间，切换不由线程本身来决定
> Java有10个线程优先级，可以建议系统为线程分配更多时间，但是根据操作系统不同，线程优先级的效果可能不同

## 状态切换
* 新建（NEW）：新创建了一个线程对象。
* 可运行（RUNNABLE）：线程对象创建后，其他线程（比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权 。
* 运行（RUNNING）：可运行状态（runnable）的线程获得了cpu时间片（timeslice），执行程序代码。
* 阻塞（BLOCKED）：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得cpu timeslice 转到运行（running）状态。阻塞的情况分三种：
    * 等待阻塞：运行（running）的线程执行o.wait()方法，JVM会把该线程放入等待队列（waitting queue）中。
    * 同步阻塞：运行（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。
    * 其他阻塞：运行（running）的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行（runnable）状态。
* 死亡（DEAD）：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

![](./img/thread_1.png)

[返回目录](../CONTENTS.md)