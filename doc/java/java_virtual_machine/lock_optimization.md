# 锁优化
## 自旋锁与自适应自旋
* 互斥部分的代码执行时间一般很短
* 不再让冲突的线程等待（阻塞恢复的代价是很大的-线程阻塞和唤醒需要CPU从用户态转为核心态），而是让线程进入一个忙循环（自旋）
* 如果自旋超过一定次数，就让冲突的线程阻塞
* 自适应自旋就是根据前一次在相同锁上的自旋时间来决定本次自旋的时间

## 锁消除
* 即时编译器在运行时，对代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除

## 锁粗化
* 当一系列连续的操作都对一个对象进行反复的加锁和解锁，甚至加锁操作是放在循环体中的，会出现大量的性能损耗，锁粗化就是将这些操作合并在一个同步块中

## 轻量级锁
* 利用对象的头信息中的“Mark Word”部分，使用CAS操作尝试将其更新为指向Lock Record的指针（包含owner和Displaced Mark Word（用于存放原Mark Word的））。
* 如成功说明已经拥有锁，标志位转为“00”
* 如果失败，首先检查“Mark Word”是否指向当前栈帧，如果是，直接进入同步块，否则说明锁对象已经被其他线程抢占，膨胀为重量级锁，标志位变成“10”
* 解锁过程使用CAS将Displaced Mark Word替换到Mark Word部分，如果替换成功，同步完成，替换失败，说明有其他线程尝试获取该锁，在释放的同时，唤醒被挂起的线程
* 提升性能是依据绝大部分锁是不存在竞争这一前提下的

## 偏向锁
* 基于轻量级锁的进一步优化，
* **锁第一次被线程获取的时候，用CAS把获取锁的线程ID记录在Mark Word中**，如果CAS成功，则持有偏向锁，每次线程进入锁的同步块时，都不需要进行同步操作
* 当另一个线程获取该锁时，偏向模式就结束了，根据现在对象是否被锁定恢复到未锁定“01”或者轻量级锁定“00”，后续的同步操作依照轻量级锁执行
* **适用于只有一个线程访问同步块的场景**

![](./img/lock_optimization_1.png)

* 偏向锁、轻量级锁、重量级锁三者各自的应用场景
    * 偏向锁：只有一个线程进入临界区；
    * 轻量级锁：多个线程交替进入临界区；
    * 重量级锁：多个线程同时进入临界区。
* 例子
```
synchronized (lockObject) {
    // do something
}
```
* 假设上面同步代码块中存在一个临界区，当前存在Thread#1和Thread#2两个用户线程，分三种情况来讨论：
    * 情况一：只有Thread#1会进入临界区；
    * 情况二：Thread#1和Thread#2交替进入临界区；
    * 情况三：Thread#1和Thread#2同时进入临界区。
* 情况一是偏向锁的适用场景，当Thread#1进入临界区时，JVM会将lockObject的对象头Mark Word的锁标志位设为“11”，同时会用CAS操作把Thread#1的线程ID记录到Mark Word中，此时进入偏向模式。所谓“偏向”，指的是这个锁会偏向于Thread#1，若接下来没有其他线程进入临界区，则Thread#1再出入临界区无需再执行任何同步操作。也就是说，若只有Thread#1会进入临界区，实际上只有Thread#1初次进入临界区时需要执行CAS操作，以后再出入临界区都不会有同步操作带来的开销。

* 然而情况一是一个比较理想的情况，更多时候Thread#2也会尝试进入临界区。若Thread#2尝试进入时Thread#1已退出临界区，即此时lockObject处于未锁定状态，这时说明偏向锁上发生了竞争（对应情况二），此时会撤销偏向，Mark Word中不再存放偏向线程ID，而是存放hashCode和GC分代年龄，同时锁标识位变为“01”（表示未锁定），这时Thread#2会获取lockObject的轻量级锁。因为此时Thread#1和Thread#2交替进入临界区，所以偏向锁无法满足需求，需要膨胀到轻量级锁。

* 再说轻量级锁什么时候会膨胀到重量级锁。若一直是Thread#1和Thread#2交替进入临界区，那么没有问题，轻量锁hold住。一旦在轻量级锁上发生竞争，即出现“Thread#1和Thread#2同时进入临界区”的情况，轻量级锁就hold不住了。 （根本原因是轻量级锁没有足够的空间存储额外状态，此时若不膨胀为重量级锁，则所有等待轻量锁的线程只能自旋，可能会损失很多CPU时间）

[返回目录](../CONTENTS.md)