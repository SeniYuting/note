# 腾讯

## 一面
1. nginx介绍（负载均衡）
```
1）模块
   a）Handler：处理器模块，直接处理请求；
   b）Filter：过滤器模块，对其他处理器模块输出的内容进行修改；
   c）Proxy：代理类模块，实现服务代理和负载均衡；
2）进程模型
   nginx启动后，会有一个master进程和多个worker进程
   a）master进程，管理worker进程，包括：接收来自外界的信号，向各worker进程发送信号
   b）worker进程，多个worker进程之间是对等的，同等竞争来自客户端的请求，各进程相互独立
```
2. 文件上传
* 使用百度Web Uploader实现，Web Uploader原理：也支持事件机制，比如：on, off，once，trigger
3. SQL索引机制
```
分为：聚集索引和非聚集索引
1）聚集索引：顺序排列，如：一个逐渐自增的表为聚集索引
2）非聚集索引：即：有序目录，一种以空间换时间的方法，如：针对非主键的某一字段添加B+树索引（非聚集索引），则排序后，只需要查询此目录（即：查询B+树）。
   索引存在存储开销和处理开销，适用于查询为主、插入为辅的情况
```
4. CDN
* 内容分发网络（见：阿里前端面试）
5. 快排算法描述
* 递归进行
* 求第500大的O（n）算法，类似快排，分治法解决
6. 状态码
* 302：临时重定向，请求的资源临时从不同的URI响应
* 502：网关或代理服务器从上游服务器收到无效响应
* 504：网关或代理服务器未能从上游服务器收到响应
7. Hibernate的缓存机制
```
包括：
1）一级缓存（session级别）
   事务级缓存，伴随着事务的开启而开启，伴随着事务的关闭而关闭
   session级别的缓存是Hibernate内置的，一定使用
2）二级缓存（sessionFactory级别）
   分为内置缓存和外置缓存
   a）内置缓存：存放映射元数据和预定义SQL语句，内置缓存只读
   b）外置缓存：存储数据库数据的副本，介质：内存或硬盘
3）查询缓存
   加上@Cacheable注解即可
```
* 注：Hibernate延迟加载，只有使用到该对象的数据时才会真正创建
* 注：Hibernate工作原理：
```
1）读取并解析配置文件。
2）读取并解析映射信息，创建SessionFactory。
3）打开Session。
4）创建事物Transaction。
5）持久化操作。
6）提交事务。
7）关闭Session。
8）关闭SessionFactory。
```
* 注：Hibernate检索数据的方式
```
1）利用类间关系：student.getAge()
2）OID检索：Session的get()和load()
3）HQL检索
```
8. DNS
* 主机名与IP地址
* 使用UDP传输
* 域名空间：顶级域名、二级域名、三级域名…
9. Spring拦截器Interceptor原理
```
拦截器：对处理器进行预处理和后处理，是链式调用
实现：继承实现了HandlerInterceptor接口的类，HandlerInterceptor接口中定义了三个方法：
1）preHandle()：处理请求前调用
2）postHandle()：处理请求后调用
3）afterCompletion()：当前Interceptor的preHandle方法返回值为true才执行
```
10. Spring IoC/DI
```
1）IoC：Inversion of Control，控制反转，用于完成对象的创建和依赖注入管理
2）IoC容器的实现原理就是工厂模式+反射机制
注：工厂模式：提供了创建对象的最佳方式
3）java用@interface定义一个注解
4）依赖注入的方式
   a）set注入
   b）构造方法注入
   c）基于注解注入@Autowired
```
11. Spring AOP
* 面向切面编程，将共有的代码全部抽取出来，放置在某个地方集中管理，如：日志记录、事务控制、权限控制等
* AOP的两种实现方式
    * JDK动态代理实现
    * cglib实现
* （10和11是Spring的两大特征）
12. MyBatis持久层框架
* 支持普通SQL查询、存储过程和高级映射
13. 树的遍历（树是特殊的图）
```
1）广度优先遍历BFS – 图
    BFS() {
  	    输入起始点；
        初始化所有顶点标记；
        初始化一个队列queue并将起始点放入队列；
        while（queue不为空）{
       	    从队列中删除一个顶点s并标记为已遍历； //表示遍历了s
    		将s邻接的所有还没遍历的点加入队列；
  		}
    }
2）深度优先遍历DFS – 图
   分为：中序遍历、前序遍历和后序遍历
```
14. 事务的隔离级别
```
1）Read Uncommitted读未提交
2）Read Committed读已提交
3）Repeatable Read可重复读
4）Serializable可串行化
不考虑隔离性问题（并发问题）：
1）脏读
2）不可重复读：一个事务范围，两个相同查询返回不同数据（由于其他事务的修改操作）
3）幻读：由于其他事务的插入等操作，产生不同的查询结果
```
15. ORM：对象关系映射Object Relational Mapping
* 在编程语言里实现：虚拟对象数据库

## 二面
1. 关系数据库和非关系数据库区别
* 关系型数据库
    * 采用关系模式组织（二维表格模型）
    * 只支持基本数据类型
    * 最大特点：事务一致性，支持ACID特性
    * 使用SQL操作数据库，可用于复杂查询
    * 支持安全性能很高的数据访问
* 非关系型数据库
    * 键值对存储数据
    * 支持文档数据、图片数据等
    * 一般不支持ACID，无事务机制，支持CAP
    * 无需经过SQL解析，读写性能很高
    * 可以处理灵活的业务数据
2. Redis和Memcache比较
```
1. 存储方式：
   Memcache将数据全部存储在内存中，断电后数据不可恢复
   Redis定期将数据存储到硬盘上，保证持久性
2. 备份
   Redis支持数据的备份，即：master-slave模式的备份
   Memcache要额外提供
3. 网络IO模型
   Memcache是多线程的，有监听主线程和worker子线程，主线程监听网络请求并传递给worker线程
   Redis是单线程的，一个Event Loop实现高并发
4. 数据一致性
   Memcache提供了cas命令，保证数据一致性
   Redis提供事务机制，保证数据一致性
5. 数据结构
   Memcache只支持简单的key-value存储
   Redis支持key-value, set, list等多种数据结构
```
3. 进程间通信IPC
```
每个进程有不同的用户地址空间，任何进程的全局变量另一个进程不可见，进程间交换数据必须通过内核；进程1把数据从用户空间拷贝到内核缓冲区，进程2从内核缓冲区将数据读走；

1. 消息队列 message queue
    https://www.cnblogs.com/tianqing/p/7110468.html
    消息生产者Producer将消息发送到消息队列，消息消费者Consumer从消息队列接收消息
    一般采用发布/订阅模型
   消息有ACK确认机制，当Consumer处理完消息后，发送ACK给消息队列，消息队列删除消息
   应用：Kafka
2. 信号量 semaphore
   是一个计数器，控制多个进程对共享资源的访问
3. 管道 pipe
    https://blog.csdn.net/qq_33724710/article/details/52345509
   无格式字节流单向流动，一般用于父子进程，子进程fork后会指向父进程管道的读端和写端
4. 共享内存 shared memory
    映射一段能被其他进程访问的内存，是最快的IPC
    注：Java内存模型中，多线程通信的主要方式就是共享内存
5. Socket
6. Java中的进程间通信还有RMI：
   JVM上的对象像调用本地对象一样，调用另一个JVM上对象的方法
```
4. Linux命令
```
1. top：CPU状态监视
  free：内存状态显示
2. ps：查看所有正在运行的进程
3. grep：文本搜索 -c：计算匹配到的行数
4. tail -f：不停查看日志文件
5. wc：计算字数
6. ls：-l：查看非隐藏文件的详情，-a：显示隐藏文件
7. lsof –i:80 查看80端口占用
8. scp：把本地文件拷贝到远程服务器
```
5. Collection
```
ArrayList 数组-查找方便
LinkedList 双向链表-插入删除方便
Vector
Stack
HashMap
Hashtable
ConcurrentHashMap
HashSet
TreeMap
TreeSet
```

## 现场面
1. 为什么选非关系型
* 基于键值对的，不需要经过SQL层的解析，性能高
* 数据之间没有耦合，容易水平扩展
2. 数据库高并发的处理
* 使用缓存
* 批量读取：多个请求合并到一个，减少数据库的访问次数
* 延迟修改：多次修改请求先保存到缓存，再定时更新到数据库
* 分表：将表中多余内容分离
* 分离活跃数据：如：将活跃用户保存为一张表
* 分布式：将单次请求的多项业务逻辑分配到多个服务器上，可以同步处理
3. 存储过程和视图的区别
* 存储过程是程序化的SQL，存储在数据库内，SQL语句实现了预编译，执行速度快
* 视图是虚拟表，通过视图访问的数据不作为独特对象存储在数据库内
4. sizeof在32位操作系统和64位操作系统的区别
* 32位操作系统和64位操作系统：内存寻址范围2^32和2^64
* sizeof：对对象求内存大小（对象数据类型的大小）
* 64位操作系统，long和指针字节是8，32位操作系统是4
5. 16个石子，一次可以拿1,3,6个，取到最后一个的人必胜，先手拿几个必胜?
* 本题而言，显然0的时候是必败点，看1，只能选择拿走1个，变成0，0是必败点，所以1是必胜点，然后看2，2的下一步只能选择拿走1个变成1，1是必胜点，2只能到达必胜点，所以2是必败点，3的下一步2和0，都是必败点，所以3是必胜点.......同理，当推到16的时候，下一步有三种走法，分别是15,13,10,由前面推理过程，15和10都是必胜点，只有13是必败点。因此先手应该选择拿走3个棋子，让对手进入必败点。

[返回目录](../../CONTENTS.md)